# thq_algo
算法刷题golang实现
## 高频面试题

1. [两数之和](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L14)
2. [链表相加](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L27)
3. [无重复字符最长子串](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L57)
4. [最长回文子串](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L111)
5. [三数之和](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L141)
6. [删除链表的倒数第 N 个结点](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L174)
7. [有效的括号](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L195)
8. [合并两个有序链表](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L224)
9. [反转链表](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L252)
10. [两两交换链表中的节点](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L271)
11. [字母异位词分组](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L292)
12. [最大子数组和](https://github.com/ithaiq/thq_algo/blob/master/practice/first.go#L320)


## 数据结构
### 二叉树
1. [前序遍历递归形式和非递归形式](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
2. [中序遍历递归形式和非递归形式](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
3. [后序遍历递归形式和非递归形式](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
4. [DFS、BFS](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
5. [归并、快速排序](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)

例题：

1. [给定一个二叉树，找出其最大深度。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
2. [给定一个二叉树，判断它是否是高度平衡的二叉树。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
3. [给定一个非空二叉树，返回其最大路径和。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
4. [给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
5. [给定一个二叉树，返回其节点值自底向上的层次遍历。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
6. [给定一个二叉树，返回其节点值的锯齿形层次遍历。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
7. [给定一个二叉树，判断其是否是一个有效的二叉搜索树。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
8. [给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
9. [二叉树的序列化与反序列化](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
10. [二叉树的序列化与反序列化](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
11. [填充每个节点的下一个右侧节点指针 I](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
12. [填充每个节点的下一个右侧节点指针 II](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
13. [从前序与中序遍历序列构造二叉树](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)
14. [从中序与后序遍历序列构造二叉树](https://github.com/ithaiq/thq_algo/blob/master/data_structure/二叉树.go)

### 链表

例题：

1. [给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L11)
2. [给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L36)
3. [反转一个单链表](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#59)
4. [反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#72)
5. [将两个升序链表合并为一个新的升序链表并返回](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L102)
6. [给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L130)
7. [在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L155)
8. [给定一个单链表 L：L→L→…→L__n→L 将其重新排列后变为： L→L__n→L→L__n→L→L__n→…](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L187)
9. [给定一个链表，判断链表中是否有环。](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L200)
10. [给定一个链表，返回链表开始入环的第一个节点](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L218)
11. [请判断一个链表是否为回文链表](https://github.com/ithaiq/thq_algo/blob/master/data_structure/链表.go#L242)

## 基础算法


## 算法思维

## 技巧细节注意
1. 切片[:]返回原切片,[:0]返回空切片
2. string遍历用for i:=0;i<len(str);i++ 遍历得到的是byte
3. 排序
    ```
    sort.Ints([]int{})
    // 字符串排序
    sort.Strings([]string{})
    // 自定义排序
    sort.Slice(s,func(i,j int)bool{return s[i]<s[j]})
   ```
4. 切片append扩容指针地址会变